"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fullDocumentRange = fullDocumentRange;
exports.getCurrentLine = getCurrentLine;
exports.isFirstInsideBlock = isFirstInsideBlock;
exports.getWordAtPosition = getWordAtPosition;
exports.getBlockAtPosition = getBlockAtPosition;
exports.getSymbolBeforePosition = getSymbolBeforePosition;
exports.positionIsAfterFieldAndType = positionIsAfterFieldAndType;
exports.isInsideGivenProperty = isInsideGivenProperty;
exports.isInsideAttribute = isInsideAttribute;
exports.isInsideFieldArgument = isInsideFieldArgument;
exports.getValuesInsideSquareBrackets = getValuesInsideSquareBrackets;
const constants_1 = require("../constants");
const block_1 = require("./block");
function fullDocumentRange(document) {
    const lastLineId = document.lineCount - 1;
    return {
        start: { line: 0, character: 0 },
        end: { line: lastLineId, character: constants_1.MAX_SAFE_VALUE_i32 },
    };
}
function getCurrentLine(document, line) {
    return document.getText({
        start: { line: line, character: 0 },
        end: { line: line, character: constants_1.MAX_SAFE_VALUE_i32 },
    });
}
function isFirstInsideBlock(position, currentLine) {
    if (currentLine.trim().length === 0) {
        return true;
    }
    const stringTilPosition = currentLine.slice(0, position.character);
    const matchArray = /\w+/.exec(stringTilPosition);
    if (!matchArray) {
        return true;
    }
    return (matchArray.length === 1 &&
        matchArray.index !== undefined &&
        stringTilPosition.length - matchArray.index - matchArray[0].length === 0);
}
function getWordAtPosition(document, position) {
    const currentLine = getCurrentLine(document, position.line);
    // search for the word's beginning and end
    const beginning = currentLine.slice(0, position.character + 1).search(/\S+$/);
    const end = currentLine.slice(position.character).search(/\W/);
    if (end < 0) {
        return '';
    }
    return currentLine.slice(beginning, end + position.character);
}
function getBlockAtPosition(fileUri, line, schema) {
    for (const block of (0, block_1.getBlocks)(schema)) {
        if (fileUri !== block.definingDocument.uri) {
            continue;
        }
        if (block.range.start.line > line) {
            return;
        }
        if (line <= block.range.end.line) {
            return block;
        }
    }
    return;
}
function getSymbolBeforePosition(document, position) {
    return document.getText({
        start: {
            line: position.line,
            character: position.character - 1,
        },
        end: { line: position.line, character: position.character },
    });
}
function positionIsAfterFieldAndType(position, document, wordsBeforePosition) {
    const symbolBeforePosition = getSymbolBeforePosition(document, position);
    const symbolBeforeIsWhiteSpace = symbolBeforePosition.search(/\s/);
    const hasAtRelation = wordsBeforePosition.length === 2 && symbolBeforePosition === '@';
    const hasWhiteSpaceBeforePosition = wordsBeforePosition.length === 2 && symbolBeforeIsWhiteSpace !== -1;
    return wordsBeforePosition.length > 2 || hasAtRelation || hasWhiteSpaceBeforePosition;
}
// checks if e.g. inside 'fields' or 'references' attribute
function isInsideGivenProperty(currentLineUntrimmed, wordsBeforePosition, attributeName, position) {
    if (!isInsideAttribute(currentLineUntrimmed, position, '[]')) {
        return false;
    }
    // We sort all attributes by their position
    const sortedAttributes = [
        {
            name: 'fields',
            position: wordsBeforePosition.findIndex((word) => word.includes('fields')),
        },
        {
            name: 'references',
            position: wordsBeforePosition.findIndex((word) => word.includes('references')),
        },
    ].sort((a, b) => (a.position < b.position ? 1 : -1));
    // If the last attribute (higher position)
    // is the one we are looking for we are in this attribute
    if (sortedAttributes[0].name === attributeName) {
        return true;
    }
    else {
        return false;
    }
}
/***
 * @param symbols expects e.g. '()', '[]' or '""'
 */
function isInsideAttribute(currentLineUntrimmed, position, symbols) {
    let numberOfOpenBrackets = 0;
    let numberOfClosedBrackets = 0;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === symbols[0]) {
            numberOfOpenBrackets++;
        }
        else if (currentLineUntrimmed[i] === symbols[1]) {
            numberOfClosedBrackets++;
        }
    }
    return numberOfOpenBrackets > numberOfClosedBrackets;
}
function isInsideFieldArgument(currentLineUntrimmed, position) {
    const symbols = '()';
    let numberOfOpenBrackets = 0;
    let numberOfClosedBrackets = 0;
    for (let i = 0; i < position.character; i++) {
        if (currentLineUntrimmed[i] === symbols[0]) {
            numberOfOpenBrackets++;
        }
        else if (currentLineUntrimmed[i] === symbols[1]) {
            numberOfClosedBrackets++;
        }
    }
    return numberOfOpenBrackets >= 2 && numberOfOpenBrackets > numberOfClosedBrackets;
}
function getValuesInsideSquareBrackets(line) {
    const regexp = /\[([^\]]+)\]/;
    const matches = regexp.exec(line);
    if (!matches || !matches[1]) {
        return [];
    }
    const result = matches[1].split(',').map((name) => {
        name = name
            // trim whitespace
            .trim()
            // remove ""?
            .replace('"', '')
            .replace('"', '');
        // Remove period at the end for composite types
        if (name.endsWith('.')) {
            return name.slice(0, -1);
        }
        return name;
    });
    return result;
}
//# sourceMappingURL=findAtPosition.js.map