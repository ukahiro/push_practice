"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = format;
const _1 = require(".");
const internals_1 = require("./internals");
function format(schema, initiatingDocument, options, onError) {
    console.log('running format() from prisma-schema-wasm');
    try {
        if (process.env.FORCE_PANIC_PRISMA_SCHEMA) {
            (0, internals_1.handleFormatPanic)(() => {
                console.debug('Triggering a Rust panic...');
                _1.prismaSchemaWasm.debug_panic();
            });
        }
        const result = _1.prismaSchemaWasm.format(JSON.stringify(schema), JSON.stringify(options));
        // tuples of [filePath, content]
        const formattedFiles = JSON.parse(result);
        const formatResult = formattedFiles.find(([uri]) => uri === initiatingDocument.uri);
        if (!formatResult) {
            return initiatingDocument.getText();
        }
        return formatResult[1];
    }
    catch (e) {
        const err = e;
        console.warn('\nprisma-schema-wasm errored during formatting. Please report this issue on [Prisma Language Tools](https://github.com/prisma/language-tools/issues). \nLinter output:\n');
        (0, internals_1.handleWasmError)(err, 'format', onError);
        return initiatingDocument.getText();
    }
}
//# sourceMappingURL=format.js.map